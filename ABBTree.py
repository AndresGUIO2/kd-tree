# -*- coding: utf-8 -*-
"""ABB Tress.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s7GEKnqUHcVGPP9VsgGVXBpqYqVhf_66

# **ABB Trees**
"""

from typing import Callable, Iterable, Sized, SupportsIndex, Union

import numpy as np

class Node:
    def __init__(
        self,
        point: SupportsIndex,
        depth: int,
        left: "Node" = None,
        right: "Node" = None,
    ) -> None:
        self.point = point
        self.left = left
        self.right = right
        self.depth = depth

    def __repr__(self) -> str:
        return f"""Node (\n  point = {self.point}, \n  depth = {self.depth}, \n  left = {"Node" if self.left else None},\n  right = {"Node" if self.right else None},\n)"""

class ABBTree:
    def __init__(
        self, points: Iterable[int]
    ) -> None:
        if len(points) == 0:
            raise ValueError("Points must not be empty")

        self.root = self.__build(points, 0)

    def __build(self, points: Iterable[int], depth: int = 0) -> Node:
        if len(points) == 0:
            return None

        sorted_points = sorted(points)
        median = len(points) // 2
        mp = sorted_points[median]

        return Node(
            mp,
            depth,
            left=self.__build(sorted_points[:median], depth + 1),
            right=self.__build(sorted_points[median + 1 :], depth + 1),
        )

    def maximo(actualNode: Node, previousNode: Node = None):
        if actualNode == None:
          return previousNode

        return ABBTree.maximo(actualNode.right, actualNode)

    @staticmethod
    def __recursive_search(point: int, node: Node):
         if node is None:
             return None

         if np.array_equal(point, node.point):
             return node

         if point <= node.point:
             found = ABBTree.__recursive_search(point, node.left)
         else:
             found = ABBTree.__recursive_search(point, node.right)

         return found

    def search(self, point: int) -> Node:
         return self.__recursive_search(point, self.root)

    @staticmethod
    def __recursive_insertion(point: int, node: Node, depth: int = 0):
      if node is None:
        node = Node(
            point,
            depth
        )
      elif node.point >= point:
        node.left = ABBTree.__recursive_insertion(point, node.left, depth + 1)
      else:
        node.right = ABBTree.__recursive_insertion(point, node.right, depth + 1)

      return node

    def insert(self, point: int) -> Node:
      return self.__recursive_insertion(point, self.root)

    @staticmethod
    def __recursive_deletion(point: int, node: Node, depth: int = 0):
      if node is None:
        return node
      elif node.point > point:
        node.left = ABBTree.__recursive_deletion(point, node.left, depth + 1)
      elif node.point < point:
        node.right = ABBTree.__recursive_deletion(point, node.right, depth + 1)
      else:
        if node.left == None:
          return node.right
        elif node.right == None:
          return node.left
        else:
          nodoActualDerecho = node.right
          node = node.left
          ABBTree.maximo(node).right = nodoActualDerecho
      return node

    def delete(self, point: int) -> Node:
      return self.__recursive_deletion(point, self.root)

    def __repr__(self) -> str:
        string = "ABBTree (\n"

        def get_repr(node, depth = 0):
            nonlocal string
            if node is None:
                return
            string += "    " * depth + str(node.point) + "\n"
            get_repr(node.left, depth + 1)
            get_repr(node.right, depth + 1)

        get_repr(self.root)
        return string + ")"

points = np.random.randint(0, 15, (7))
p = np.random.randint(0, 15, 2)

tree = ABBTree(points)
print(tree)

result = tree.search(14)

if not result:
  print("El punto no se encuentra en el Ã¡rbol.")
else:
  print(result)

result = tree.insert(15)
print(tree)

result = tree.delete(10)
print(tree)

